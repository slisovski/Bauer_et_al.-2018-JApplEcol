{
    "collab_server" : "",
    "contents" : "#include \"RcppArmadillo.h\"\n// [[Rcpp::depends(RcppArmadillo)]]\n \n// Namespace for Parameters\nnamespace sdp {\n\n// Init\nint MaxT;\nint NSites;\nint MaxX;\n\n// Individual\ndouble B0;\ndouble w;\ndouble  xc;\narma::vec b0;\narma::vec b1;\narma::vec b2;\ndouble pred_a1;\ndouble pred_a2;\ndouble c;\ndouble speed;\narma::vec WindAssist;\narma::vec WindProb;\narma::vec ZStdNorm;\narma::vec PStdNorm;\ndouble decError;\n\n// Sites  \narma::mat dist;\narma::mat x_gain;\narma::mat y_gain;\narma::mat p_gain;\narma::vec nTR_x;\narma::vec nTR_y;\nRcpp::NumericVector expend;\n\n// Output\narma::cube FMatrix;\narma::cube DMatrix1;\narma::cube DMatrix2;\narma::cube PMatrix1;\narma::cube PMatrix2;\n\n// Internal paramters\ndouble Fintensity = 0.0;\n\n}\n\n// Eval (not exported):\n// Function use to truncate value to range between min and max\nint Eval(\n    double x, \n    double min, \n    double max\n) \n{\n  return (x <= min) ? 0 : ((x >= (max)) ? 2 : 1);\n}\n\n\n// Decision Error (not exported)\n// Function to calculate decision error based on the importance of the decision\ndouble DecError(\n    double var,\n    double decError\n)\n{\n  double help1 = 1.0 + (decError * var);\n  double help  = 1.0 / help1;\n  return help;\n}\n\n// Round (not exported)\n// Function equivalent to round(value, 0) in R\nint Round(double value)\n{  \n  if (value - floor(value) < 0.5) return (int)(value);\n  else return ((int)(value) + 1);\n}\n\n// Sigmoidal TR function (not exported)\ninline double FNtanh(double g)\n{\n  return ((( (exp(g) - exp(-g)) / (exp(g) + exp(-g)) ) + 1.0)/ 2.0);\n}\n\n// InterpolateTR\n// Function to derive Terminal Reward for t\ndouble InterpolateTR (int c_tr,\n                      arma::vec  c_nTR_x,\n                      arma::vec  c_nTR_y) \n{\n  int i = 0;\n  double help = 0.0;\n  double help_t = (double)(c_tr);\n  double min = 0.0; double max = 2.0;\n  \n  while((c_nTR_x(i) < help_t) && (i < (c_nTR_x.size()))) ++i;\n  if((i==0) || (c_nTR_x(i) - c_nTR_x[i-1]) == 0)\n    help = c_nTR_y(i);\n  else\n    help = c_nTR_y(i-1) + \n      (c_nTR_y(i) - c_nTR_y(i-1))/\n        (c_nTR_x(i) - c_nTR_x(i-1)) * (help_t - c_nTR_x(i-1));\n  \n  if (help < min) help = min;\n  if (help > max) help = max;\n  return help;\n}\n\n// CalculateTR\n// Function to calculate the Terminal Reward\ndouble CalculateTR(int c_x, \n                   int c_t, \n                   double     c_w, \n                   double     c_xc, \n                   const int  c_B0,\n                   arma::vec  c_nTR_x,\n                   arma::vec  c_nTR_y) \n{\n  double TimeReward, StateReward, TR_tmp = 0.0;\n  \n  TimeReward = InterpolateTR(c_t, c_nTR_x, c_nTR_y);\n  if (c_x == 0) StateReward = 0.0;\n  else StateReward = FNtanh(c_w * ((double)(c_x) - c_xc));\n  \n  TR_tmp = TimeReward * StateReward + c_B0;\n  return TR_tmp;\n}\n\n\n////////////////////////////////////////////////////////////////\n////// Functions used in Backward and Forward Simulation ///////\n////////////////////////////////////////////////////////////////\n\n// Interpolate\n// Get gain values for time and site\ndouble Interpolate(\n    const int& time,\n    const int& s,\n    double min, \n    double max,\n    bool p\n)\n{\n  int i = 1;\n  double help;\n  double nGains = sdp::x_gain.n_cols;\n  \n  if (!p) \n  {\n    while((sdp::x_gain(s, i) < time) && (i < (nGains-1))) ++i;\n    if ((i == 1) || ((sdp::x_gain(s, i) - sdp::x_gain(s, i-1)) == 0))\n      help = sdp::y_gain(s, i);\n    else\n      help = sdp::y_gain(s, i-1) + (sdp::y_gain(s, i) - sdp::y_gain(s, i-1))/\n        (sdp::x_gain(s, i) - sdp::x_gain(s, i-1))*(time - sdp::x_gain(s, i-1));\n    \n    if (help < min) help = min;\n    if (help > max) help = max;\n    \n    return help;\n  } \n  else\n  {\n    while((sdp::x_gain(s, i) < time) && (i < (nGains-1))) ++i;\n    if ((i == 1) || ((sdp::x_gain(s, i) - sdp::x_gain(s, i-1)) == 0))\n      help = sdp::p_gain(s, i);\n    else\n      help =  sdp::p_gain(s, i-1) + (sdp::p_gain(s, i) - sdp::p_gain(s, i-1))/\n        (sdp::x_gain(s, i) - sdp::x_gain(s, i-1))*(time - sdp::x_gain(s, i-1));\n    \n    if (help < min) help = min;\n    if (help > max) help = max;\n    \n    return help;\n  }\n} // end Interpolate\n\n\n// Predation\n// Calculates the reduction in fitness based on predation\ndouble Predation (\n    const int& time, \n    const int& site, \n    const int& x,\n    double u,\n    double f\n)\n{\n  const double rew_tol = 0.0000005;\n  double netgain, cor_u, cor_x;\n  \n  cor_u = u;\n  cor_x = (double)(x);\n  netgain = ((u * f) - sdp::expend(site));\n  if (netgain <= 0.0) netgain = rew_tol;\n  if (cor_u   <= 0.0) cor_u   = rew_tol;\n  if (cor_x   <= 0.0) cor_x   = rew_tol;\n  \n  double help1 = exp((sdp::pred_a1 + 1) * log(cor_x + netgain));\n  double help2 = exp((sdp::pred_a1 + 1) * log(cor_x));\n  double help3 = (sdp::pred_a1 + 1.0) * netgain;\n  double help4 = exp(sdp::pred_a2 * log(cor_u));\n  double help5 = sdp::b0(site) + sdp::b1(site) * ((help1 - help2)/help3) * sdp::b2(site) * help4;\n  \n  // double help1 = sdp::b1(site) * (pow(cor_u, sdp::pred_a1));\n  // double help2 = sdp::b2(site) * (pow(cor_x/((double)(sdp::MaxX)), sdp::pred_a2));\n  // double help5 = sdp::b0(site) + help1 + help2;\n  \n  return help5;\n} // end Predation\n\n\n// FindFitness value\n// Interpolates FitnessValue for time, site, x and feeding intensity\ndouble FindF (\n    const int& time, \n    const int& site, \n    const int& x,\n    int accuracy, \n    double gain, \n    double fx, \n    double u\n)\n{\n  double res1, res2, part1, part2, interpolReward;\n  res1 = 0.0; res2 = 0.0; part1 = 0.0; part2 = 0.0;\n  \n  double expenditure = sdp::expend(site);\n  double nextx = (double)(x) + gain * u - expenditure;\n  switch (Eval(nextx, 0.0, (double)(sdp::MaxX)))\n  {\n  case 0: interpolReward = sdp::FMatrix(time+1, site, 0); break;\n  case 1: {    res1 = nextx - (int)(nextx);\n    res2 = (int)(nextx) + 1.0 - nextx;\n    \n    part1 = res1 * sdp::FMatrix(time+1, site, (int)(nextx)+1);\n    part2 = res2 * sdp::FMatrix(time+1, site, (int)(nextx));\n    interpolReward = part1 + part2;\n    break;\n  }    \n  case 2: interpolReward = sdp::FMatrix(time+1, site, sdp::MaxX); break;\n  }\n  double fx_new = fx + (sdp::PStdNorm(accuracy) * interpolReward);\n  return fx_new;\n} // end FindF\n\n\n// Foraging\n// Major Foraging function: Optimization of Foraging intensity\ndouble Foraging(const int& time, \n                const int& site, \n                const int& x\n)\n{\n  const double r = 0.61803399;\n  const double tol = 0.0000005;\n  double mean, gain, SD, Freward;\n  double c, u0, u1, u2, u3, f1, f2, hold1, hold2;\n  double hold1_old, hold2_old, f1_old, f2_old;\n  int NStdNorm = sdp::ZStdNorm.size();\n  \n  c = 1.0 - r;\n  u0 = 0.0;\n  u1 = r;\n  u3 = 1.0;\n  u2 = u1 + c * (u3 - u1);\n  \n  f1 = 0.0; f2 = 0.0;\n  \n  mean = Interpolate(time, site, -99999999.9, 99999999.9, false);\n  SD   = Interpolate(time, site, 0.0, 99999999.9, true);\n  \n  for (int accuracy = 0; accuracy < NStdNorm; ++accuracy)\n  {\n    gain = mean + sdp::ZStdNorm(accuracy) * SD;\n    f1_old = f1;\n    f2_old = f2;\n    f1 = FindF(time, site, x, accuracy, gain, f1_old, u1);\n    f2 = FindF(time, site, x, accuracy, gain, f2_old, u2);\n  }\n  \n  f1_old = f1;\n  f2_old = f2;\n  f1 = (1.0 - Predation(time, site, x, u1, f1)) * f1;\n  f2 = (1.0 - Predation(time, site, x, u2, f2)) * f2;\n  \n  while ((fabs(u3 - u0)) > tol)\n  {\n    if (f2 > f1)\n    {\n      u0 = u1;\n      u1 = u2;\n      u2 = (r * u1) + (c * u3);\n      hold2 = 0.0;\n      for (int accuracy = 0; accuracy < NStdNorm; ++accuracy)\n      {\n        gain = mean + sdp::ZStdNorm(accuracy) * SD;\n        hold2_old = hold2;\n        hold2 = FindF(time, site, x, accuracy, gain, hold2_old, u2);\n      }\n      f1 = f2;\n      f2 = ((1.0 - Predation(time, site, x, u2, hold2)) * hold2);\n    }\n    if (f2 <= f1)\n    {\n      u3 = u2;\n      u2 = u1;\n      u1 = (r * u2) + (c * u0);\n      hold1 = 0.0;\n      for (int accuracy = 0; accuracy < NStdNorm; ++accuracy)\n      {\n        gain = mean + sdp::ZStdNorm(accuracy) * SD;\n        hold1_old = hold1;\n        hold1 = FindF(time, site, x, accuracy, gain, hold1_old, u1);\n      }\n      f2 = f1;\n      f1 = ((1.0 - Predation(time, site, x, u1, hold1)) * hold1);\n    }\n  }  //end of while loop\n  \n  if (f1 <= f2)\n  {\n    sdp::Fintensity = u2;\n    Freward = f2;\n  }\n  else //(f1 > f2)\n  {\n    sdp::Fintensity = u1;\n    Freward = f1;\n  }\n  return Freward;\n} // end Foraging\n\n\n// Flying\n// Major Flying Function - find best locatioon for time, site and x \ndouble Flying(\n    const int& time, \n    const int& site, \n    const int& x, \n    int dep_site)\n{\n  double totalD, Whold, range, Sqr_c, Sqr_ca;\n  double distance, t, interpolReward, nextx;\n  double res1, res2, tim1, tim2, part1, part2, part3, part4;\n  \n  interpolReward = 0.0;\n  totalD = 0.0;\n  Whold = 0.0;\n  \n  range = sdp::c * (1.0 - (1.0/ (sqrt(1.0 + (double)(x)/(double)(sdp::MaxX))))); //determine Range\n  \n  totalD = sdp::dist(site, dep_site);\n  for (int h = 0; h < sdp::WindProb.size(); ++h)\n  {\n    distance = totalD * (1.0 + sdp::WindAssist(h));\n    \n    Sqr_c = (sdp::c * sdp::c);\n    Sqr_ca = (sdp::c - (range - distance))*(sdp::c - (range - distance));\n    nextx = ((Sqr_c/Sqr_ca) - 1.0) * sdp::MaxX;\n    t = (double)(time) + (distance / sdp::speed);\n    \n    \n    if (t >= (sdp::MaxT)) interpolReward = 0.0;\n    else  if (nextx <= 0.0) interpolReward = 0.0;\n    else\n    {\n      res1 = nextx - (int)(nextx);\n      res2 = (int)(nextx) + 1.0 - nextx;\n      tim1 = t - (int)(t);\n      tim2 = (int)(t) + 1.0 - t;\n      \n      if ((nextx+1.0) > (double)(sdp::MaxX))\n      {\n        part1 = tim1*res1*sdp::FMatrix((int)(t)+1, dep_site, sdp::MaxX);\n        part3 = tim2*res1*sdp::FMatrix((int)(t),   dep_site, sdp::MaxX);\n      }\n      else\n      {\n        part1 = tim1*res1*sdp::FMatrix((int)(t)+1, dep_site, (int)(nextx)+1);\n        part3 = tim2*res1*sdp::FMatrix((int)(t),   dep_site, (int)(nextx)+1);\n      }\n      part2 = tim1*res2*sdp::FMatrix((int)(t)+1, dep_site, (int)(nextx));\n      part4 = tim2*res2*sdp::FMatrix((int)(t),   dep_site, (int)(nextx));\n      interpolReward = part1+part2+part3+part4;\n    }\n    double help_old = Whold;\n    Whold = help_old + sdp::WindProb(h) * interpolReward;\n  } //End h\n  return Whold;\n}  // end Flying\n\n\n////////////////////////////////////////////////////////////////\n////// Export Functions: Backward Iteration ////////////////////\n////////////////////////////////////////////////////////////////\n\n\n// [[Rcpp::export]]\nvoid Init( int MaxT,\n           int NSites,\n           int MaxX,\n           double w,\n           double xc,\n           int B0,\n           Rcpp::NumericVector b0,\n           Rcpp::NumericVector b1,\n           Rcpp::NumericVector b2,\n           double pred_a1,\n           double pred_a2,\n           double c,\n           double speed,\n           Rcpp::NumericVector WindAssist,\n           Rcpp::NumericVector WindProb,\n           Rcpp::NumericVector ZStdNorm,\n           Rcpp::NumericVector PStdNorm,\n           Rcpp::NumericVector nTR_x,\n           Rcpp::NumericVector nTR_y,\n           double decError,\n           arma::mat dist,\n           arma::mat x_gain,\n           arma::mat y_gain,\n           arma::mat p_gain,\n           Rcpp::NumericVector expend\n           )\n{\n  // Basic Parms\n  sdp::MaxT   = MaxT;\n  sdp::NSites = NSites;\n  sdp::MaxX   = MaxX;\n  \n  // Individual\n  sdp::B0 = B0;\n  sdp::w = w;\n  sdp::xc = xc;\n  sdp::b0 = b0;\n  sdp::b1 = b1;\n  sdp::b2 = b2;\n  sdp::pred_a1 = pred_a1;\n  sdp::pred_a2 = pred_a2;\n  sdp::c = c;\n  sdp::speed = speed;\n  sdp::WindAssist = WindAssist;\n  sdp::WindProb = WindProb;\n  sdp::ZStdNorm = ZStdNorm;\n  sdp::PStdNorm = PStdNorm;\n  sdp::nTR_x = nTR_x;\n  sdp::nTR_y = nTR_y;\n  sdp::decError = decError;\n  \n  // Sites  \n  sdp::dist   = dist;\n  sdp::x_gain = x_gain;\n  sdp::y_gain = y_gain;\n  sdp::p_gain = p_gain;\n  sdp::expend = expend;\n \n  sdp::Fintensity = 0.0; \n}\n\n\n// [[Rcpp::export]]\nRcpp::List BackwardIteration() {\n  \n  /// Terminal Reward\n  arma::cube FM_TR = arma::zeros<arma::cube>(sdp::MaxT+1, sdp::NSites+1, sdp::MaxX+1);\n  \n  for (int r = 0; r <= sdp::MaxT; ++r)\n  {\n    for (int c = 0; c <= sdp::MaxX; ++c)\n    {\n      FM_TR(r, sdp::NSites, c) = CalculateTR(c, r, sdp::w, sdp::xc, sdp::B0, sdp::nTR_x, sdp::nTR_y);\n    }\n  }\n  \n  for (int r = 0; r < sdp::NSites; ++r)\n  {\n    for (int c = 0; c <= sdp::MaxX; ++c)\n    {\n      FM_TR(sdp::MaxT, r, c) = sdp::B0;\n    }\n  }\n  \n  sdp::FMatrix  = FM_TR;\n  sdp::DMatrix1 = arma::zeros<arma::cube>(sdp::NSites+1, sdp::MaxT+1, sdp::MaxX+1);\n  sdp::DMatrix2 = arma::zeros<arma::cube>(sdp::NSites+1, sdp::MaxT+1, sdp::MaxX+1);\n  sdp::PMatrix1 = arma::zeros<arma::cube>(sdp::NSites+1, sdp::MaxT+1, sdp::MaxX+1);\n  sdp::PMatrix2 = arma::zeros<arma::cube>(sdp::NSites+1, sdp::MaxT+1, sdp::MaxX+1);\n  \n  \n  arma::vec  Mrew(sdp::NSites+1);\n  double     max_Reward, decision;\n  Rcpp::List out(6);\n\n  // Progress bar\n  // Progress p((sdp::MaxT-1)*(sdp::NSites), progressbar);\n\n  for (int time = (sdp::MaxT-1); time >= 0; --time)\n  {\n    for (int site = 0; site < (sdp::NSites); ++site)\n    {\n      sdp::FMatrix(time, site, 0) = 0.0;\n      // p.increment(); // update progress\n\n      for(int x = 1; x <= (sdp::MaxX); ++x) {\n\n        sdp::Fintensity = 0.0;\n        max_Reward = 0.0;\n        decision = 0.0;\n\n        double f_help = Foraging(time, site, x);\n        sdp::FMatrix(time, site, x) = f_help;\n\n        decision   = - sdp::Fintensity - 1.0;\n        sdp::DMatrix1(site, time, x) = decision;\n\n        max_Reward = Foraging(time, site, x);\n\n        for (int bb = 0; bb <= sdp::NSites; ++bb) Mrew(bb) = 0.0;\n        for (int dest = (site+1); dest <= sdp::NSites; ++dest)\n        {\n          float help_z = Flying(time, site, x, dest);\n          Mrew[dest] = help_z;\n        }\n\n        double help_flying = 0.0;\n        int best_bb = 0;\n        for (int bb = 0; bb <= sdp::NSites; ++bb)\n        {\n          if (Mrew[bb] > help_flying)\n          {\n            help_flying = Mrew(bb);\n            best_bb = bb;\n            sdp::DMatrix2(site, time, x) = (double)(bb);\n            if (help_flying > max_Reward) max_Reward = help_flying;\n          }\n        }\n\n        sdp::PMatrix1(site, time, x) = DecError((max_Reward - sdp::FMatrix(time, site, x))/max_Reward, sdp::decError);\n        sdp::PMatrix2(site, time, x) = DecError((max_Reward - Mrew(best_bb))/max_Reward, sdp::decError);\n\n        double sum_action = sdp::PMatrix1(site, time, x) + sdp::PMatrix2(site, time, x);\n\n        sdp::PMatrix1(site, time, x) /= sum_action;\n        sdp::PMatrix2(site, time, x) /= sum_action;\n\n        sdp::FMatrix(time, site, x)   = max_Reward;\n\n      } // end x\n    } // end site\n  } // end time\n\n  out[0] = sdp::FMatrix;\n  out[1] = sdp::DMatrix1;\n  out[2] = sdp::DMatrix2;\n  out[3] = sdp::PMatrix1;\n  out[4] = sdp::PMatrix2;\n  out[5] = sdp::expend;\n  \n  return out;\n}\n\n\n////////////////////////////////////////////////////////////////\n////// Export Functions: Forward Simulation ////////////////////\n////////////////////////////////////////////////////////////////\n\n// [[Rcpp::export]]\nvoid InitSim (int MaxT,\n              int NSites,\n              int MaxX,\n              double w,\n              double xc,\n              int B0,\n              Rcpp::NumericVector b0,\n              Rcpp::NumericVector b1,\n              Rcpp::NumericVector b2,\n              double pred_a1,\n              double pred_a2,\n              double c,\n              double speed,\n              Rcpp::NumericVector WindAssist,\n              Rcpp::NumericVector WindProb,\n              Rcpp::NumericVector ZStdNorm,\n              Rcpp::NumericVector PStdNorm,\n              Rcpp::NumericVector nTR_x,\n              Rcpp::NumericVector nTR_y,\n              double decError,\n              arma::mat dist,\n              arma::mat x_gain,\n              arma::mat y_gain,\n              arma::mat p_gain,\n              Rcpp::NumericVector expend,\n              arma::cube FMatrix,\n              arma::cube DMatrix1,\n              arma::cube DMatrix2,\n              arma::cube PMatrix1,\n              arma::cube PMatrix2)\n{\n  // Basic Parms\n  sdp::MaxT   = MaxT;\n  sdp::NSites = NSites;\n  sdp::MaxX   = MaxX;\n  \n  // Individual\n  sdp::B0 = B0;\n  sdp::w = w;\n  sdp::xc = xc;\n  sdp::b0 = b0;\n  sdp::b1 = b1;\n  sdp::b2 = b2;\n  sdp::pred_a1 = pred_a1;\n  sdp::pred_a2 = pred_a2;\n  sdp::c = c;\n  sdp::speed = speed;\n  sdp::WindAssist = WindAssist;\n  sdp::WindProb = WindProb;\n  sdp::ZStdNorm = ZStdNorm;\n  sdp::PStdNorm = PStdNorm;\n  sdp::nTR_x = nTR_x;\n  sdp::nTR_y = nTR_y;\n  sdp::decError = decError;\n  \n  // Sites  \n  sdp::dist   = dist;\n  sdp::x_gain = x_gain;\n  sdp::y_gain = y_gain;\n  sdp::p_gain = p_gain;\n  sdp::expend = expend;\n  \n  sdp::FMatrix  = FMatrix;\n  sdp::DMatrix1 = DMatrix1;\n  sdp::DMatrix2 = DMatrix2;\n  sdp::PMatrix1 = PMatrix1;\n  sdp::PMatrix2 = PMatrix2;\n  \n  sdp::Fintensity = 0.0; \n}\n\n\n// [[Rcpp::export]]\narma::vec simForaging(double f_intensity, int time, int site, int x)\n{\n  double gain, new_x = 0.00, mean, SD, Predat, Runif, pre_x;\n  double LB, UB;\n  int hit = 0, dead = false;\n  int NStdNorm = sdp::ZStdNorm.size();\n  arma::vec out = arma::zeros<arma::vec>(2);\n  \n  Runif = R::runif(0,1);\n  LB = 0.0;\n  UB = 0.0;\n  for (int h = 0; h < NStdNorm; ++h)\n  {\n    UB += sdp::PStdNorm(h);\n    if ((Runif > LB) && (Runif <= UB))\n      hit = h;\n    LB += sdp::PStdNorm(h);\n  }\n  mean = Interpolate(time, site, -99999999.9, 99999999.9, false);\n  SD =   Interpolate(time, site, 0.0, 99999999.9, true);\n  \n  double temp_gain = mean + sdp::ZStdNorm(hit) * SD;\n  gain = temp_gain;\n  if (gain < 0.0) gain = 0.0;\n  \n  pre_x = double(x);\n  double expenditure = sdp::expend(site);\n  \n  new_x = pre_x + f_intensity * gain - expenditure;\n  \n  switch(Eval(new_x, 0.0, sdp::MaxX))\n  {\n  case 0: x = 0; break;\n  case 1: x = Round(new_x); break;\n  case 2: x = sdp::MaxX; break;\n  };\n  \n  if ((f_intensity > 0.0) && (gain > 0.0) && (pre_x > 0.0))\n  {\n    double help1 = exp((sdp::pred_a1 + 1.0) * log(pre_x + f_intensity * gain));\n    double help2 = exp((sdp::pred_a1 + 1.0) * log(pre_x));\n    double help3 = (sdp::pred_a1 + 1.0) * f_intensity * gain;\n    double help4 = exp(sdp::pred_a2 * log(f_intensity));\n    Predat = sdp::b0(site) + sdp::b1(site) *\n      ((help1 - help2)/help3) * sdp::b2(site) * help4;\n  }\n  else Predat = sdp::b0(site);\n  \n  if (Predat > 0.0)\n  {\n    if (R::runif(0, 1) < Predat) dead = true;\n  }\n  \n  out(0) = Round(new_x);\n  out(1) = dead;\n  return out;\n}\n\n// [[Rcpp::export]]\narma::vec simFlying(int decision, int time, int site, int x)\n{\n  double nextx, total_D, distance, range;\n  double Sqr_c, Sqr_ca, t, UB, LB, Runif;\n  int hit = 0;\n  int NWind = sdp::WindAssist.size();\n  arma::vec out = arma::zeros<arma::vec>(2);\n  \n  int dest_site = decision;\n  total_D = 0.0;\n  total_D = sdp::dist(site, dest_site);\n\n  Runif = R::runif(0,1);\n  LB = 0.0;\n  UB = 0.0;\n  for (int h = 0; h < NWind; ++h)\n  {\n    UB += sdp::WindProb(h);\n    if ((Runif > LB ) && (Runif <= UB))\n      hit = h;\n    LB += sdp::WindProb(h);\n  }\n  distance = total_D * (1.0 + sdp::WindAssist(hit));\n  \n  range = sdp::c * (1.0 - (1.0/ (sqrt(1.0 + (double)(x)/(double)(sdp::MaxX)))));\n  \n  Sqr_c  = (sdp::c * sdp::c);\n  Sqr_ca = (sdp::c - (range - distance))*(sdp::c - (range - distance));\n  nextx  = (((Sqr_c/Sqr_ca) - 1.0) * (double)(sdp::MaxX));\n  \n  t =  time + (distance/ sdp::speed);\n  \n  out(0) = Round(t);\n  out(1) = Round(nextx);\n  return out;\n}\n\n// [[Rcpp::export]]\narma::cube forwardSim(int Ind, int start_time, int start_site, arma::vec start_x)\n{\n  \n  double decision = 0.0;\n  arma::vec fl_help = arma::zeros<arma::vec>(2);\n  arma::vec fo_help = arma::zeros<arma::vec>(2);\n  arma::cube SimOut = arma::zeros<arma::cube>(Ind, 5, (sdp::MaxT));\n    \n    for (int indiv = 0; indiv < Ind; ++indiv)\n     {\n       SimOut(indiv, 2, 0) = Round(start_x(0) + R::runif(-start_x(1), start_x(1)));\n       SimOut(indiv, 1, 0) = start_site;\n       SimOut(indiv, 0, 0) = start_time;\n     }  \n    \n    for (int time = (start_time+1); time < sdp::MaxX; ++time)\n    {\n      for (int indiv = 0; indiv < Ind; ++indiv)\n      {\n        if ((SimOut(indiv, 0, time-1) <= time) && (SimOut(indiv, 4, time-1) == 0) &&\n            (SimOut(indiv, 1, time-1) <  sdp::NSites))\n        {\n        \n        if (R::runif(0,1) < sdp::PMatrix1(SimOut(indiv, 1, time-1), time-1, SimOut(indiv, 2, time-1))) {\n                 decision = sdp::DMatrix1(SimOut(indiv, 1, time-1), time-1, SimOut(indiv, 2, time-1));\n        } else {\n                 decision = sdp::DMatrix2(SimOut(indiv, 1, time-1), time-1, SimOut(indiv, 2, time-1));\n        }\n        \n        if (decision >= 0.0)\n            {\n            fl_help = simFlying(decision, time-1, SimOut(indiv, 1, time-1), SimOut(indiv, 2, time-1));\n            int nextt = fl_help(0);\n            if (nextt<=SimOut(indiv, 0, time-1)) nextt = nextt+1;\n            int nextx = fl_help(0);\n            if (nextx < 0) nextx = 0;\n            SimOut(indiv, 0, time) = nextt;\n            SimOut(indiv, 1, time) = decision;\n            SimOut(indiv, 2, time) = nextx;\n            } \n            else {\n              fo_help = simForaging(fabs(decision+1.0),time-1, SimOut(indiv, 1, time-1), SimOut(indiv, 2, time-1));\n              int newx = fo_help(0);\n              int dead = fo_help(1);\n              if( newx > sdp::MaxX) newx = sdp::MaxX;\n              SimOut(indiv, 0, time) = time;\n              SimOut(indiv, 1, time) = SimOut(indiv, 1, time-1);\n              SimOut(indiv, 2, time) = newx;\n              SimOut(indiv, 3, time) = fabs(decision+1.0);\n              SimOut(indiv, 4, time) = dead;\n            }\n        \n        } else {\n          SimOut(indiv,0,time) = SimOut(indiv,0,time-1)+1;\n          SimOut(indiv,1,time) = SimOut(indiv,1,time-1);\n          SimOut(indiv,2,time) = SimOut(indiv,2,time-1);\n          SimOut(indiv,4,time) = SimOut(indiv,4,time-1);\n        }\n        if (SimOut(indiv, 2, time) <= 0) {\n            SimOut(indiv, 4, time)  = true;\n            SimOut(indiv, 2, time)  = 0.0;\n        }\n      }\n    }\n\n  return SimOut;\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1499759837500.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4117740183",
    "id" : "C6965294",
    "lastKnownWriteTime" : 1500042418,
    "last_content_update" : 1500042418999,
    "path" : "~/Dropbox/Science/Projects/SOI_Projects/SDPmig/InfectedMigration/RPackage/SDPmig/src/SdpMigC.cpp",
    "project_path" : "src/SdpMigC.cpp",
    "properties" : {
        "source_window_id" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}